# webpack-es3-error-example

A minimal example of the issue described in [webpack issue #6704](https://github.com/webpack/webpack/issues/6704).

## How to run

```sh
npm install
npm run build
npm run start
```

## Example overview

The output will be generated in the `dist` folder and is included in the repo for easier analysis, but you can of course rebuild using the above commands.

The entrypoint is `index.ts` in the `src` directory. It imports `main()` from `app.ts`, which calls `alert("Hello World)` and is the only exported object of that module.

Webpack compiles the application via the `awesome-typescript-loader` module and the local TypeScript 2.7.2 install of the project with target ES3 and bundles the generated output into `./dist/assets/app.js`. (Command: `npm run webpack`). Webpack also copies to HTML files into `dist` for browser testing.

To start the app in the browser, run `npm run start`, which starts `lite-server` and which should open a browser tab serving the `index.html`.

To see the error, launch in an affected version of the browsers. I used `Chrome 15` on Windows XP on BrowserStack for testing.

## Issue

In all modern browsers, this works fine, but in older versions of Chrome, Firefox, Safari and (afaik) Android browsers, this results in the error `Uncaught TypeError: Cannot assign to read only property '__esModule' of #<Object>` (as seen in the console).

This isssue is caused by the line `exports.__esModule = true;`, which is emitted as the first line (after `"use strict"`) in any module with imports or exports generated by TypeScript, e.g. lines 72 and 83 in [./dist/assets/app.js](./dist/assets/app.js). Afaik, this line is also generated by various other tools like Babel and serves as a general module compatibility tool.

```js
(function(module, exports, __webpack_require__) {
    "use strict";
    exports.__esModule = true;
})
```

If compatibility with older browsers is desired, it is necessary to compile TypeScript to the ES3 target, so then this error will then necessarily occur. The same line is however not emitted, if ES5 is targeted, since the output then uses `Object.defineProperty(exports, "__esModule", { value: true });`.`

## Fix

I'm not entirely sure what the cause of this error is, but defining any other export before this line will fix the error, for example:

```js
(function(module, exports, __webpack_require__) {
    "use strict";
    exports.foo = "bar";
    exports.__esModule = true;
})
```

Interestingly, the issue is also fixed, if `__esModule` is assigned a value before the module function call, e.g. by initialising it to `undefined`. This can be done when the exports object is initialised or manually, as seen on line 16 in  [./dist/app-fixed.js](./dist/app-fixed.js) and the pasted snippet from the beginning of that file below.

```js
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: { __esModule: undefined }
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
```

With this fix, the error does not occur in the old browsers anymore, it doesn't have an impact on modern browsers and the functionality of Webpack, since `exports.__esModule` is tested for truthiness and with the value `undefined`, it is virtually indistiguishable from implementations where this assignment does not occur.

While this problem only occurs for some old browsers, the fix is quite simple and only costs a handful of bytes.

## Test the fix

`npm run fix` uses `sed` to apply this modification to the generated webpack output in `./dist/assets/app.js` and writes it to `./dist/assets/app-fixed.js`. `npm run build` runs both commands sequentially.

You can now go to `fixed.html` in your browser (which loads the modified script) and will observe that it works both in modern and old browsers.

## License

MIT
